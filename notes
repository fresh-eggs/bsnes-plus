
Cartridge is loaded via the UI
	cartidge.loadXBand is called (loader.cpp:248). This happens right after we load Xband in the UI

	Catridge::LoadXBand calls loadCartridge (ui-qt/catridge.cpp:174), 

	loadCartridge (ui-qt/cartridge:501) exits with the cartridge detection and mapping having completed. It accomplishes this with the help of creating an instance of SNESCartridge, followed by collecting the relevant XML mapping of memory.

	At this point, before returning, LoadXBand changes the state of system to call power() as we are in Utility::LoadCartridge


- continue to debug the XML mapping generation, see if mapping this way gets things to work.

- try to understand how the bsx implementation leverages the XML mapping and what it then is actually doing in the cart load functions with the calls to map

- compare and contrast this with what it was doing in sx2 against plus to try and understand what the xband cart sectionts need to be doing with mapping 



LOAD BSX
--------------------------------
[*][Cartridge::load]
[*][Cartridge::parse_xml] enter
[*][Cartridge::parse_xml_cartridge] enter
[*][Cartridge::parse_xml_cartridge] doc size 2
[*][Cartridge::parse_xml_cartridge] head name is cartridge
[*][Cartridge::parse_xml_cartridge] node_name: rom
[*][Cartridge::parse_xml_cartridge] node_name: ram
[*][xml.cpp]4096
[*][Cartridge::parse_xml_cartridge] exit
[*][Cartridge::parse_xml] exit
<?xml version='1.0' encoding='UTF-8'?>
<cartridge region='NTSC'>
  <rom>
    <map mode='shadow' address='00-3f:8000-ffff'/>
    <map mode='linear' address='40-7d:0000-ffff'/>
    <map mode='shadow' address='80-bf:8000-ffff'/>
    <map mode='linear' address='c0-ff:0000-ffff'/>
  </rom>
  <ram size='1000'>
    <map mode='linear' address='20-3f:6000-7fff'/>
    <map mode='linear' address='a0-bf:6000-7fff'/>
  </ram>
</cartridge>



load XBAND mode xband
[*][Cartridge::load]
[*][Cartridge::parse_xml] enter
[*][Cartridge::parse_xml_cartridge] enter
[*][Cartridge::parse_xml_cartridge] doc size 0
[*][Cartridge::parse_xml] exit
<?xml version='1.0' encoding='UTF-8'?>
<cartridge region='NTSC'>

  <map address='00-3f:8000-ffff'>
  <map address='80-bf:8000-ffff'>
  <map address='40-7d:0000-ffff'>
  <map address='c0-df:0000-ffff'>

<mmio>
  <map address='e0-ff:0000-ffff'>
</mmio>
</cartridge>





<?xml version='1.0' encoding='UTF-8'?>
<cartridge region='NTSC'>
  <rom>
    <map mode='shadow' address='00-3f:8000-ffff'/>
    <map mode='linear' address='40-7d:0000-ffff'/>
    <map mode='shadow' address='80-bf:8000-ffff'/>
    <map mode='linear' address='c0-ff:0000-ffff'/>
  </rom>
  <ram size='10000'>
    <map mode='linear' address='20-3f:6000-7fff'/>
    <map mode='linear' address='a0-bf:6000-7fff'/>
  </ram>
</cartridge>


<?xml version='1.0' encoding='UTF-8'?>
<cartridge region='NTSC'>
  <rom>
    <map mode='direct' address='00-3f:8000-ffff'>
    <map mode='direct' address='80-bf:8000-ffff'>
    <map mode='direct' address='40-7d:0000-ffff'>
    <map mode='direct' address='c0-df:0000-ffff'>
  </rom>
  <ram size='1000'>
    <map mode='linear' address='20-3f:6000-7fff'/>
    <map mode='linear' address='a0-bf:6000-7fff'/>
  </ram>
  <mmio>
    <map address='e0-ff:0000-ffff'>
  </mmio>
</cartridge>





<?xml version='1.0' encoding='UTF-8'?>
<cartridge region='NTSC'>
  <rom>
    <map mode='linear' address='00-7d:8000-ffff'/>
    <map mode='linear' address='80-ff:8000-ffff'/>
  </rom>
</cartridge>

<?xml version='1.0' encoding='UTF-8'?>
<cartridge region='NTSC'>
  <xband>
    <rom>
      <map mode='shadow' address='00-3f:8000-ffff'>
      <map mode='linear' address='80-bf:8000-ffff'>
      <map mode='shadow' address='40-7d:0000-ffff'>
      <map mode='linear' address='c0-df:0000-ffff'>
    </rom>
    <ram size='10000'>
      <map mode='linear' address='20-3f:6000-7fff'/>
      <map mode='linear' address='a0-bf:6000-7fff'/>
    </ram>
    <mmio>
      <map address='fb-ff:c000-c1bf'>
    </mmio>
  </xband>
</cartridge>





- continue to debug why the memory map you're creating for the xband cart will not parse.

- you just tried to format it differently to include the odd one out assignment of the ROM in addition to the MIMO.

- it is printing out properly but isn't parsing.

- also, do you need an <mcu> mapping ? What is that?








[*][Cartridge::load]
[*][Cartridge::parse_xml] enter
[*][Cartridge::parse_xml_cartridge] enter
[*][Cartridge::parse_xml_cartridge] doc size 2
[*][Cartridge::parse_xml_cartridge] head name is cartridge
[*][Cartridge::parse_xml_cartridge] node_name: rom
[*][Cartridge::parse_xml_cartridge] exit
[*][Cartridge::parse_xml] exit
<?xml version='1.0' encoding='UTF-8'?>
<cartridge region='NTSC'>
  <rom>
    <map mode='linear' address='00-7d:8000-ffff'/>
    <map mode='linear' address='80-ff:8000-ffff'/>
  </rom>
</cartridge>





- still seems to be returning a doc size of 0 with your custom XML. 



- you built an XML that maps the cart to highROM but that maps requests for the XBAND rom to your handler.
  - since the XBAND cart is hirom, I think it makes sense to keep that mapping for the XML but apply some address translation afterwards to map requests to either the XBAND ROM or the slot ROM.

  - where does XBAND store the slot rom? Is it just in the normal place that roms run in a high-rom mapping? Given that it maps the XBAND rom to only an odd slice of the ROM storage, there is plenty of room left for other roms. (You could actually figure this out if you dump cartridge memory on the SNES. You could look around for a ROM header in the dump denoting where the slot ROM is mapped).


- it seems like this is working but at runtime it looks to be cycling throuhg a bunch of addresses constantly instead of starting ?

  - figure out what those addresses are and what is expected of them
  - learn about the xband boot on SNES, are there register values that need to be set in order for this not to happen?
    - read XBAND source code
    - look for changes to the other bsnes emulator that has xband working.

- also worth investigating how the address decoding logic worked on the bsx-2 implementation. Understand what it is trying to do.
  - xband ROM is mapped in a particular place. The ROM looks like it is reading but then it is reaching out for things in hardcoded places.
  - does the decoding logic help make sure those things are where the xband ROM expects?
  - if you slap the decoding logic onto your xband_cart implementation, followed by removing the extra rom mapping and leaving just the highROM mapping, does everything work ?
  - *Would it be worth building sx2 with debug printfs peppered throughout to see what the XML map looks like in addition to seeing if mimo reads are intended to be happening?
     You could get a feel for what addresses are intended to be fetched and what they are intended to return when everything is working.

-----

- worth understanding how the XBAND actually expects to boot. Read through the rom image and reverse what it is trying to do.

- given this, you should be able to figure out if mapping is needed as HiROM or a custom mapping of the XBAND handlers to the XBAND ROM space while allowing the regular handler for everything else.

- implement both and observe the addresses requested via debug information, see which one makes the most sense given what you can reverse about the expected behavior of the XBAND ROM.

NEXT 

- understand what the address translation was doing in the bsx-2 implementation.
- map those translations to what you believe would be mapped in memory to see what they are trying to translate mapped memory requests towards.
- do the same thing for bsnes-plus
- understand how SNES cartridges booted, what is the first address that is loadded into the PC ? If you can follow that, you could also spend time reversing the XBAND ROM from the start and getting an intuition for what is expected for the execution to work properly.

----

- understand how address translation works on the sx2 emu, what is it doing?
- figure out how to get address translation working on the bsnes-plus emulator, seems the rom is properly reaching into 0xdXXXXX space, simply dropping the first byte clearly doesn't work so how can I properly match the requested virutal address to the proper offset in the XBAND rom data array ?

  - using the translation provided in the sx2 emulator also does that incrementing address thing, what the hell is that ?



BSX2 address translation
--------------------------
addr = ((addr & 0x3f0000 >> 1) | (addr & 0xffff));


addr AND 0x3f0000   [mask on the first two bits]
>> 1
OR (addr AND 0xffff)


addr = 0xd3a4e3

0xd3a4e3 AND 0x3f0000
--------------------------

--------------------------
[addr AND 0x3f0000]
0011 1111  == 0x3f
1101 0001  == 0xd1
--------------------------
0xd0 AND 0x3f = 0x100000
0xd1 AND 0x3f = 0x110000
0xd2 AND 0x3f = 0x120000
0xd3 AND 0x3f = 0x130000
0xd4 AND 0x3f = 0x140000
0xd5 AND 0x3f = 0x150000
0xd6 AND 0x3f = 0x160000
0xd7 AND 0x3f = 0x170000
0xd8 AND 0x3f = 0x180000
0xd9 AND 0x3f = 0x190000
0xda AND 0x3f = 0x1a0000
0xdb AND 0x3f = 0x1b0000
0xdc AND 0x3f = 0x1c0000
0xdd AND 0x3f = 0x1d0000
0xde AND 0x3f = 0x1e0000
0xdf AND 0x3f = 0x1f0000
--------------------------
[addr^ >> 1]
0x100000 >> 1 = 0x080000
0x110000 >> 1 = 0x088000
0x120000 >> 1 = 0x090000
0x130000 >> 1 = 0x098000
0x140000 >> 1 = 0x0a0000
0x150000 >> 1 = 0x0a8000
0x160000 >> 1 = 0x0b0000
0x170000 >> 1 = 0x0b8000
0x180000 >> 1 = 0x0c0000
0x190000 >> 1 = 0x0c8000
0x1a0000 >> 1 = 0x0d0000
0x1b0000 >> 1 = 0x0d8000
0x1c0000 >> 1 = 0x0e0000
0x1d0000 >> 1 = 0x0e8000
0x1e0000 >> 1 = 0x0f0000
0x1f0000 >> 1 = 0x0f8000
-------------------------------
0x1f0000 >> 1 == 0x0f8000
0001 1111 0000 0000 0000 0000 (0x1f0000)
0000 1111 1000 0000 0000 0000 (0x0f8000)
-------------------------------
0x080000 | (addr AND 0xffff)[0x00a4e3] == 0x08a4e3
0x088000 | (addr AND 0xffff)[0x00a4e3] == 0x08a4e3
0x090000 | (addr AND 0xffff)[0x00a4e3] == 0x09a4e3
0x098000 | (addr AND 0xffff)[0x00a4e3] == 0x09a4e3
0x0a0000 | (addr AND 0xffff)[0x00a4e3] == 0x0aa4e3
0x0a8000 | (addr AND 0xffff)[0x00a4e3] == 0x0aa4e3
0x0b0000 | (addr AND 0xffff)[0x00a4e3] == 0x0ba4e3
0x0b8000 | (addr AND 0xffff)[0x00a4e3] == 0x0ba4e3
0x0c0000 | (addr AND 0xffff)[0x00a4e3] == 0x0ca4e3
0x0c8000 | (addr AND 0xffff)[0x00a4e3] == 0x0ca4e3
0x0d0000 | (addr AND 0xffff)[0x00a4e3] == 0x0da4e3
0x0d8000 | (addr AND 0xffff)[0x00a4e3] == 0x0da4e3
0x0e0000 | (addr AND 0xffff)[0x00a4e3] == 0x0ea4e3
0x0e8000 | (addr AND 0xffff)[0x00a4e3] == 0x0ea4e3
0x0f0000 | (addr AND 0xffff)[0x00a4e3] == 0x0fa4e3
0x0f8000 | (addr AND 0xffff)[0x00a4e3] == 0x0fa4e3
-------------------------------
0xd0a4e4 == 0x08a4e3
0xd1a4e4 == 0x08a4e3
0xd2a4e4 == 0x09a4e3
0xd3a4e4 == 0x09a4e3
0xd4a4e4 == 0x0aa4e3
0xd5a4e4 == 0x0aa4e3
0xd6a4e4 == 0x0ba4e3
0xd7a4e4 == 0x0ba4e3
0xd8a4e4 == 0x0ca4e3
0xd9a4e4 == 0x0ca4e3
0xdaa4e4 == 0x0da4e3
0xdba4e4 == 0x0da4e3
0xdca4e4 == 0x0ea4e3
0xdda4e4 == 0x0ea4e3
0xdea4e4 == 0x0fa4e3
0xdfa4e4 == 0x0fa4e3
--------------------------------

XBAND rom has sections starting at offset 0x8000 into each bank.

this is true for addresses in the rom at bank 0x00 - 0x0f

Does it not then make sense to AND with 0x0FFFFF in order to drop to 0xD ?

How does the emulator represent the SNES memory map? How does it handle requests for virtual addresses in the SNES address map to indexes in the stored rom data array ?

how does the rom get mapped into memory ?? the spaces between chunks in an SFC file, do those get squashed ? 

Until you understand that, it will be hard to relate the addresses requested that you're observing in the XBAND class back to a space in the SNES memory map

Like what the hell is supposed to be mapped at 0xd04ec1 ?? There is no data in the xband rom at 0x4ec1 ?

----

The startup sequence is attempting to read from the header at 00:FFD0, is it actually there?? I thought mapping of an SFC rom file was done starting at 40:0000

  - correct! Note-2 on page 2-21-4 of the SNES development manual explains this. Thanks to the mirroring in HiROM, the ROM image in range 8000-FFFF in banks C0-FF is mirrored in the same range in banks 00-3F and banks 80-BF.

  - this allows a read at 00:FFDO to resolve, simply reading the contents in 40:FFDO 



How dose the emulator read the SFC file? How does it represent it in memory? You need to undeerstand this in order to understand how to translate 0xD0 bank requests into an appropriate offset into the [cartrom] array.

if it is actually ending up in snesreader_load_normal, why isn't changing the 0xD0 requests to 0x40 working ?

----

- figure out how the cartridge data is read via reader.load call in cartridgeLoad (is it in the snesreader?)

- understand if it copies the rom verbatim, this will instruct you on what offsets you need to provide to reads into the cartrom data array to properly translate calls into banks 0xD0-0xDF to the corresponding offsets in the cartrom data array. 
----

- The ROM is a carbon copy in memory as on disk.

- why aren't the offsets you're calculating working? What parts of the rom make it to 0xD0 ?

- are hex offsets into the data_ array working as you expect? What if you use decimal?

- is the value being returned at the earlier offsets into the ROM header the actual expected value? Why are those working?

- Aren't the addresses you're receiving working in the SNES virtual address space? how can that get translated to an offset into the ROM array.

----

- you confirmed that the data_ pointer in the emulator, or wrather, cartrom, is one contiguous array of ROM data. NOT a carbon copy of the SFC file on disk.


----

- you're still trying to figure out how to get the cartridge working.

- with a little more digging, you've come to find that it is getting stuck on an instruction intended to activate a co-processor? Not sure if that is a false flag

- you've also noticed that some address manipulating was missing from bsx-2, you've added that.

- Next on the list
  - continue to persue porting SX2 work to bsnes-plus
    - get SRAM mapped and working as intended, I'm no convinced that this is working properly as BSX2 has SRAM mapped.
    - ensure that all address translation exists
    - see if this gets the cart rom running!

  - explore using your own understanding of how cartrom is mapped and use your offsets (the 0x00 offsets) into the cartrom array. The last you were doing this for read/write operations into cartrom, things started getting further and made their way to mimo_write/mimo_read.
    - neither of these were setup to work properly so you should explore making changes to perform correct address translation
    - same case with SRAM here, not 100% convinced it is working as intended.

----


- you're continuing to chase the first startegy mentioned in the blob above (re-implement xband following bsx implementation)

- it makes sense to have a _base_ class that represents the Rockwell modem and the mimo that it needs in order to function properly. It is a coprocessor. the bsx_base seems to represent the modem for bsx.

- you were in the middle of adding some missing calls to the xband_base that are present in bsx_base.

- it seems that the emulator is crashing on the call to Cartridge::load around line 141, you'll need to figure out why before continuing.

afaict, everything required for the xband_base coprocessor to work is now present in the code base. The translation of requests into the xband maped memory should reflect what was done in the bsx-2 implementation.


----

- you haven't got much farther, the emulator is now crashing in a new place since attempting to more closely match what mapping were being forced in the bsx-2 in the XML mapping in the bsnes-plus (done by moving the ram mapping in xband so you can map it)

- continue to attempt to debug the current segfault.

- might be worth burning everything down and starting the implementation from mostly scract? Either that or whiteboard the current state of the implementation.

- you could also reach out for help on the nesdev forums, anyone who is willing to try and get xband implementation working on bsnes-plus

- oh btw now the emulator looks to be arbitrarily crashing at the same system bug mapping of wram section again... fun



1101 0000
0100 0000

addr AND 0x4F0000
